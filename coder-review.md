# Тестовое ревью

## Миграция:

1. Деньги не рекомендуется хранить в float во избежание проблем с конвертацией 
и потерей точности при работе с числами с плавающей точкой. Рекомендуемый тип: int, decimal, money(для PostgreSQL).

Исправлено на `int`

2. varchar с длинной 255 - это своего рода пережиток прошлого, который в современных реалиях применяется иногда 
в силу привычки везде, где можно. Оставил комментарии с пометкой TODO в миграции. Напр, для UUID нужно всего 36 символов.
Можно сэкономить прилично места, если каталог будет большой. 

3. Индекс по полю `is_active` типа boolean скорее всего будет бесполезен, т.к. будет обладать низкой селективностью. 
Я его удалил.

4. Зачем два идентификатора ID и UUID ? Чаще всего достаточно одного. Оставил UUID. Сделал по нему unique индекс. 

5. Если товары всполедствии необходимо будет сравнивать по времени поступления, то стоит рассмотреть возможность добавления 
полей `inserted_at`, `updated_at` либо использовать UUID v7, а не v4. 
Поскольку требований не было относительно этого в ТЗ - оставил только комментарий. Но на этапе проектирования хорошо бы 
заложить такую возможность.

## Структура проекта

Общие замечания: 

1. Поскольку у нас есть папки Domain и Infrastructure предположу, что здесь есть некоторая ориентация на модель чистой
архитектуры в ее классическом варианте. 

Контроллеры являются внешним слоем и частью инфраструктуры, поэтому логично переместить их в Infrastructure.

Также в Infrastructure попадают реализации репозиториев, интерфейсы же будут лежать в Domain.

Папка с миграциями вообще находится вне `src`, что делать не рекомендуется.

**Полный список изменений и пример структуры проекта:**

src/
    Domain/
        Entities/
        UseCases/
        Repositories/  # Здесь находятся *интерфейсы* репозиториев
    Infrastructure/
        Http/
            Controllers/
            View/
        Repositories/  # Здесь находятся *реализации* репозиториев
        Database/      # Код, связанный с базой данных (например, ORM)
            /migrations

2. Много логики в контроллерах. В целом такой подход будет работать и он достаточно хорошо может быть покрыт тестами, 
при условии, что в контроллерах нет жестких зависимостей.
Но для переиспользования кода и в рамках опять же чистой архитектуры рекомендуется вынести логику в use-cases, 
что я и сделал.

3. Теперь немного деталей по логике: 

- SQL инъекции внутри ProductRepository. Исправлено путем добавления prepared statements.
- Базовый `exception` заменен на `ProductNotFoundException`
- Внутри CartView в цикле происходят запросы в таблицу `products` для получения продукта по его UUID.
Это в общем случае называется **N+1 query problem**. Исправлено путем добавления функции `getByUuidList`. Ее реализацию 
писать я не стал. 

Также стоит отметить, что View не должно иметь зависимости на репозиторий. Она убрана. 
Оставлена только подготовка данных, которые передаются через `CartDto`.

Логика внутри методов контроллера обернута в try-catch. 

- CartManager: Добавлен конкретный класс исключения `CartNotInitializedException`
- CartManager: В логировании ошибки ничего, кроме `Error` не писалось. Это потеря информации об ошибках. Исправлено.
Сделал re-throw ошибки далее.

ConnectorFacade убран. Немного не понял, какой смысл в данном классе. Сделан интерфейс коннектора и реализация.
Рассмотрена возможность использования singleton класса для подключения к Redis во избежания дублирования коннекшенов.

- ConnectorException: убрана трансляция стектрейса в методе `__toString()`, если только вы не хотите поделиться со всем миром
логами ошибок на продакшн.
Но есть куда более серьезная проблема: имплементация \Throwable. 
В PHP есть два типа исключений: Exception - базовый класс, 
представлюящий ошибки run-time, которые мы хотим обработать на уровне приложения. 
Error - базовый класс ошибок, которые не должны перехватываться приложением, напр. нехватка памяти и проч.
Сделано наследование от базового класса Exception.

RedisConnector: используется сериализация и десериализация через php-serialize. 
Почему это плохо ?
- проблемы с совместимостью старой и новой версии класса для сериализации. 
- проблемы с безопасностью при десериализации. 
- проблемы при переходе со старых версий PHP. 
- проблемы с производительностью при большом кол-ве запросов.

Как исправить? Использовать другой формат сериализации, напр. JSON. 
Сделать проверку типов как минимум.

- ProductsView: убрана зависимость на репозиторий. Оставлены только данные.

- Константа `24 * 60 * 60` = TTL корзины убрана в CartManager. 

Также еще несколько общих замечаний:

- Кое-где отсутствует строгая типизация. Часть исправлено, часть - оставлены комментарии.
- Исправлены мелкие стилистические ошибки: торчащие наружу public поля и тут же геттеры и сеттеры.
- Исправлена опечатка в имени переменной `productVew` -> `productView`.
- Нигде не нашел использования метода `saveCart`.
- Параметры коннекта к редис необходимо вынести в конфигурационный слой.
- Необходима классификация ошибок при логировании. Не просто строчка `Some exception...` для эффективного поиска. Делать
здесь я этого не стал, пишу словами. 


### То, что осталось за скоупом 

- Отсутствие глоссария и документации
- Отсутствие тестов
- Отсутствие changelog. Пример формата: https://keepachangelog.com/en/1.0.0/
